import { CodeBlock } from '../components-mdx/index.js';
import "../styles.css"

# Promesas (Promises)


En JavaScript una promesa es un objeto que representa el resultado eventual (éxito o fallo) de una operación asíncrona. 
Las promesas son utilizadas para manejar operaciones asíncronas de una manera más clara y evitar los problemas asociados con los callbacks anidados.

Una promesa puede estar en uno de los tres estados:

**Pending (Pendiente):** Estado inicial, la promesa está pendiente de resolverse o rechazarse.

**Fulfilled (Cumplida):** La operación se completó con éxito, y la promesa tiene un valor resultante.

**Rejected (Rechazada):** La operación falló, y la promesa tiene un motivo de rechazo.

 <CodeBlock
  codeString={`
    // Creación de una promesa
    const myPromise = new Promise((resolve, reject) => {
    // Simulación de una operación asíncrona
    setTimeout(() => {
        const success = true; // Cambiar a false para simular un fallo

        if (success) {
        resolve('¡La operación fue exitosa!');
        } else {
        reject('¡La operación falló!');
        }
    }, 2000); // Simula una operación que tarda 2 segundos
    });

    // Uso de la promesa con then y catch
    myPromise
    .then((result) => {
        console.log('Éxito:', result);
    })
    .catch((error) => {
        console.error('Error:', error);
    });
  `} 
  language='javascript'
/>

### En este ejemplo:

Se crea una nueva promesa **myPromise** que simula una operación asíncrona usando setTimeout.

Dentro de la promesa se resuelve **resolve** o rechaza **reject** la promesa según el resultado de la operación.

Se utiliza el método **.then()** para manejar el caso en que la promesa se resuelve con éxito.

Se utiliza el método **.catch()** para manejar el caso en que la promesa es rechazada.

# Tips

#### Manejo de Errores

Siempre maneja los errores en las cadenas de promesas. Usa **catch** al final de la cadena para capturar cualquier error que ocurra en cualquier parte de la cadena.

<CodeBlock
  codeString={`
  miPromesa()
    .then(resultado => console.log(resultado))
    .catch(error => console.error(error));
  `} 
  language='javascript'
/>

#### Evitar Promesas sin Retorno

Asegúrate de que tus funciones de promesa devuelvan un valor o resuelvan con algún resultado. Olvidar hacerlo puede llevar a problemas difíciles de depurar.

<CodeBlock
  codeString={`
  // Incorrecto
  const promesaSinRetorno = () => new Promise(resolve => resolve());

  // Correcto
  const promesaConRetorno = () => new Promise(resolve => resolve('¡Éxito!'));
  `} 
  language='javascript'
/>

#### Uso de Promise.all

Tip: Utiliza **Promise.all** para manejar múltiples promesas concurrentes. Esto asegura que todas las promesas se completen antes de continuar.

<CodeBlock
  codeString={`
  const promesas = [promesa1(), promesa2(), promesa3()];

  Promise.all(promesas)
    .then(resultados => console.log(resultados))
    .catch(error => console.error(error));
  `} 
  language='javascript'
/>

#### Async/Await

Usa **async/await** para escribir código asincrónico de manera más sincrónica y legible.

<CodeBlock
  codeString={`
  async function miFuncionAsincrona() {
    try {
      const resultado = await miPromesa();
      console.log(resultado);
    } catch (error) {
      console.error(error);
    }
  }
  `} 
  language='javascript'
/>