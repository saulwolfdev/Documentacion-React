import { CodeBlock } from '../components-mdx/index.js';

# Async - Await

**Async/await** es una característica de JavaScript que simplifica la escritura y lectura del código **asíncrono**. 
Te permite trabajar con promesas de una manera más estructurada y legible.

Cuando defines una función con la palabra clave **async** antes de ella, estás indicando que esa función retornará una promesa. 
Luego, puedes utilizar la palabra clave **await** dentro de la función para esperar que una promesa se resuelva antes de continuar con la ejecución del código.

Este enfoque es particularmente útil al tratar con operaciones asíncronas, como solicitudes a servidores, lectura de archivos, o cualquier tarea que tome un tiempo y no 
bloquee el hilo principal de ejecución.

**ejemplo de cómo se usa async/await para hacer una solicitud HTTP:**

<CodeBlock
  codeString={`
  const obtenerDatos = async ( ) => {
  try {
    const response = await fetch('https://api.example.com/data');

    if (!response.ok) {
      throw new Error(Error: {response.status});
    }

    const data = await response.json();
    console.log('Datos:', data);
    // Podes realizar acciones con los datos aquí
  } catch (error) {
    console.error('Error:', error);
  }
};

// Llamada a la función para obtener datos
obtenerDatos();
  `} 
  language='javascript'
/>

### CallBacks

Antes de que se introdujera **async/await en ECMAScript 2017**, la forma común de manejar operaciones asíncronas en JavaScript era a través de **callbacks y promesas**.

**1. Callbacks -Promesas:**

Los callbacks eran funciones que se pasaban como argumentos a otras funciones y se ejecutaban una vez que la operación asíncrona se completaba.
Esto a menudo resultaba en código anidado conocido como **"callback hell" o "infierno de callbacks"**, lo cual era difícil de mantener y entender.

Ejemplo usando callbacks:

<CodeBlock
  codeString={`
  function obtenerDatos(callback) {
    setTimeout(function( ) {
      const datos = 'Estos son los datos';
      callback(datos);
    }, 2000);
  }

  obtenerDatos(function(datos) {
    console.log(datos);
  });
  `} 
  language='javascript'
/>

**2. Promesas:**

Las promesas proporcionaron una forma más estructurada y legible de manejar operaciones asíncronas, evitando el problema del callback hell.

Las promesas tienen dos posibles estados: **fulfilled (cumplida)** o **rejected (rechazada)** y permiten encadenar operaciones usando los métodos **.then() y .catch()**.

Ejemplo usando promesas:

<CodeBlock
  codeString={`
  function obtenerDatos( ) {
    return new Promise((resolve, reject) => {
      setTimeout(function( ) {
        const exito = true; // Indica si la operación fue exitosa o no

        if (exito) {
          resolve('La operación fue exitosa');
        } else {
          reject('La operación falló');
        }
      }, 2000);
    });
  }

  obtenerDatos( )
    .then((mensaje) => {
      console.log(mensaje); // La operación fue exitosa
    })
    .catch((error) => {
      console.error(error); // La operación falló
    });
  `} 
  language='javascript'
/>

Si bien las promesas proporcionaron una mejora significativa en la gestión de código asíncrono, **async/await** simplificó aún más el proceso al permitir que el código se 
escribiera de una manera que se asemeja al código síncrono, haciendo que sea más fácil de leer y mantener.